<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>State Space Models in Stan</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Documentation for State Space Models in Stan.">
  <meta name="generator" content="bookdown 0.0.73 and GitBook 2.6.7">

  <meta property="og:title" content="State Space Models in Stan" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Documentation for State Space Models in Stan." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="State Space Models in Stan" />
  
  <meta name="twitter:description" content="Documentation for State Space Models in Stan." />
  

<meta name="author" content="Jeffrey B. Arnold">

<meta name="date" content="2016-07-02">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="filtering-and-smoothing.html">
<link rel="next" href="other-software.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>

$$
\DeclareMathOperator{\E}{E}
\DeclareMathOperator{\mean}{mean}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Cor}{Cor}
\DeclareMathOperator{\Bias}{Bias}
\DeclareMathOperator{\MSE}{MSE}
\DeclareMathOperator{\sd}{sd}
\DeclareMathOperator{\se}{se}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\VEC}{vec}

\newcommand{\mat}[1]{\boldsymbol{#1}}
\newcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\T}{'}

\newcommand{\distr}[1]{\mathcal{#1}}
\newcommand{\dnorm}{\distr{N}}
\newcommand{\dmvnorm}[1]{\distr{N}_{#1}}
\newcommand{\dt}[1]{\distr{T}_{#1}}

\newcommand{\cia}{\perp\!\!\!\perp}
\DeclareMathOperator*{\plim}{plim}
$$

  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">State Space Models in Stan</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="the-linear-state-space-model.html"><a href="the-linear-state-space-model.html"><i class="fa fa-check"></i><b>2</b> The Linear State Space Model</a></li>
<li class="chapter" data-level="3" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html"><i class="fa fa-check"></i><b>3</b> Filtering and Smoothing</a><ul>
<li class="chapter" data-level="3.1" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#filtering"><i class="fa fa-check"></i><b>3.1</b> Filtering</a></li>
<li class="chapter" data-level="3.2" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#smoothing"><i class="fa fa-check"></i><b>3.2</b> Smoothing</a><ul>
<li class="chapter" data-level="3.2.1" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#state-smoothing"><i class="fa fa-check"></i><b>3.2.1</b> State Smoothing</a></li>
<li class="chapter" data-level="3.2.2" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#disturbance-smoothing"><i class="fa fa-check"></i><b>3.2.2</b> Disturbance smoothing</a></li>
<li class="chapter" data-level="3.2.3" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#fast-state-smoothing"><i class="fa fa-check"></i><b>3.2.3</b> Fast state smoothing</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#simulation-smoothers"><i class="fa fa-check"></i><b>3.3</b> Simulation smoothers</a><ul>
<li class="chapter" data-level="3.3.1" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#mean-correction-simulation-smoother"><i class="fa fa-check"></i><b>3.3.1</b> Mean correction simulation smoother</a></li>
<li class="chapter" data-level="3.3.2" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#de-jong-shephard-method"><i class="fa fa-check"></i><b>3.3.2</b> de Jong-Shephard method</a></li>
<li class="chapter" data-level="3.3.3" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#forward-filter-backwards-smoother-ffbs"><i class="fa fa-check"></i><b>3.3.3</b> Forward-filter backwards-smoother (FFBS)</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#missing-observations"><i class="fa fa-check"></i><b>3.4</b> Missing observations</a></li>
<li class="chapter" data-level="3.5" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html#forecasting-matrices"><i class="fa fa-check"></i><b>3.5</b> Forecasting matrices</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="stan-functions.html"><a href="stan-functions.html"><i class="fa fa-check"></i><b>4</b> Stan Functions</a><ul>
<li class="chapter" data-level="4.1" data-path="stan-functions.html"><a href="stan-functions.html#utility-functions"><i class="fa fa-check"></i><b>4.1</b> Utility Functions</a><ul>
<li class="chapter" data-level="4.1.1" data-path="stan-functions.html"><a href="stan-functions.html#to_symmetric_matrix"><i class="fa fa-check"></i><b>4.1.1</b> to_symmetric_matrix</a></li>
<li class="chapter" data-level="4.1.2" data-path="stan-functions.html"><a href="stan-functions.html#to_matrix_colwise"><i class="fa fa-check"></i><b>4.1.2</b> to_matrix_colwise</a></li>
<li class="chapter" data-level="4.1.3" data-path="stan-functions.html"><a href="stan-functions.html#to_matrix_rowwise"><i class="fa fa-check"></i><b>4.1.3</b> to_matrix_rowwise</a></li>
<li class="chapter" data-level="4.1.4" data-path="stan-functions.html"><a href="stan-functions.html#to_vector_colwise"><i class="fa fa-check"></i><b>4.1.4</b> to_vector_colwise</a></li>
<li class="chapter" data-level="4.1.5" data-path="stan-functions.html"><a href="stan-functions.html#to_vector_rowwise"><i class="fa fa-check"></i><b>4.1.5</b> to_vector_rowwise</a></li>
<li class="chapter" data-level="4.1.6" data-path="stan-functions.html"><a href="stan-functions.html#symmat_size"><i class="fa fa-check"></i><b>4.1.6</b> symmat_size</a></li>
<li class="chapter" data-level="4.1.7" data-path="stan-functions.html"><a href="stan-functions.html#find_symmat_dim"><i class="fa fa-check"></i><b>4.1.7</b> find_symmat_dim</a></li>
<li class="chapter" data-level="4.1.8" data-path="stan-functions.html"><a href="stan-functions.html#vector_to_symmat"><i class="fa fa-check"></i><b>4.1.8</b> vector_to_symmat</a></li>
<li class="chapter" data-level="4.1.9" data-path="stan-functions.html"><a href="stan-functions.html#symmat_to_vector"><i class="fa fa-check"></i><b>4.1.9</b> symmat_to_vector</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="stan-functions.html"><a href="stan-functions.html#filtering-1"><i class="fa fa-check"></i><b>4.2</b> Filtering</a><ul>
<li class="chapter" data-level="4.2.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_a"><i class="fa fa-check"></i><b>4.2.1</b> ssm_filter_update_a</a></li>
<li class="chapter" data-level="4.2.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_p"><i class="fa fa-check"></i><b>4.2.2</b> ssm_filter_update_P</a></li>
<li class="chapter" data-level="4.2.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_v"><i class="fa fa-check"></i><b>4.2.3</b> ssm_filter_update_v</a></li>
<li class="chapter" data-level="4.2.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_f"><i class="fa fa-check"></i><b>4.2.4</b> ssm_filter_update_F</a></li>
<li class="chapter" data-level="4.2.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_finv"><i class="fa fa-check"></i><b>4.2.5</b> ssm_filter_update_Finv</a></li>
<li class="chapter" data-level="4.2.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_k"><i class="fa fa-check"></i><b>4.2.6</b> ssm_filter_update_K</a></li>
<li class="chapter" data-level="4.2.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_l"><i class="fa fa-check"></i><b>4.2.7</b> ssm_filter_update_L</a></li>
<li class="chapter" data-level="4.2.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_update_ll"><i class="fa fa-check"></i><b>4.2.8</b> ssm_filter_update_ll</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="stan-functions.html"><a href="stan-functions.html#filtering-2"><i class="fa fa-check"></i><b>4.3</b> Filtering</a><ul>
<li class="chapter" data-level="4.3.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_idx"><i class="fa fa-check"></i><b>4.3.1</b> ssm_filter_idx</a></li>
<li class="chapter" data-level="4.3.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_size"><i class="fa fa-check"></i><b>4.3.2</b> ssm_filter_size</a></li>
<li class="chapter" data-level="4.3.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_loglik"><i class="fa fa-check"></i><b>4.3.3</b> ssm_filter_get_loglik</a></li>
<li class="chapter" data-level="4.3.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_v"><i class="fa fa-check"></i><b>4.3.4</b> ssm_filter_get_v</a></li>
<li class="chapter" data-level="4.3.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_finv"><i class="fa fa-check"></i><b>4.3.5</b> ssm_filter_get_Finv</a></li>
<li class="chapter" data-level="4.3.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_k"><i class="fa fa-check"></i><b>4.3.6</b> ssm_filter_get_K</a></li>
<li class="chapter" data-level="4.3.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_a"><i class="fa fa-check"></i><b>4.3.7</b> ssm_filter_get_a</a></li>
<li class="chapter" data-level="4.3.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_p"><i class="fa fa-check"></i><b>4.3.8</b> ssm_filter_get_P</a></li>
<li class="chapter" data-level="4.3.9" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter"><i class="fa fa-check"></i><b>4.3.9</b> ssm_filter</a></li>
<li class="chapter" data-level="4.3.10" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states"><i class="fa fa-check"></i><b>4.3.10</b> ssm_filter_states</a></li>
<li class="chapter" data-level="4.3.11" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_get_a"><i class="fa fa-check"></i><b>4.3.11</b> ssm_filter_states_get_a</a></li>
<li class="chapter" data-level="4.3.12" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_get_p"><i class="fa fa-check"></i><b>4.3.12</b> ssm_filter_states_get_P</a></li>
<li class="chapter" data-level="4.3.13" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states-1"><i class="fa fa-check"></i><b>4.3.13</b> ssm_filter_states</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="stan-functions.html"><a href="stan-functions.html#log-likelihood"><i class="fa fa-check"></i><b>4.4</b> Log-likelihood</a><ul>
<li class="chapter" data-level="4.4.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_lpdf"><i class="fa fa-check"></i><b>4.4.1</b> ssm_lpdf</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="stan-functions.html"><a href="stan-functions.html#time-invariant-kalman-filter"><i class="fa fa-check"></i><b>4.5</b> Time-Invariant Kalman Filter</a><ul>
<li class="chapter" data-level="4.5.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_check_matrix_equal"><i class="fa fa-check"></i><b>4.5.1</b> ssm_check_matrix_equal</a></li>
<li class="chapter" data-level="4.5.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_constant_lpdf"><i class="fa fa-check"></i><b>4.5.2</b> ssm_constant_lpdf</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="stan-functions.html"><a href="stan-functions.html#common-smoother-functions"><i class="fa fa-check"></i><b>4.6</b> Common Smoother Functions</a><ul>
<li class="chapter" data-level="4.6.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_update_r"><i class="fa fa-check"></i><b>4.6.1</b> ssm_smooth_update_r</a></li>
<li class="chapter" data-level="4.6.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_update_n"><i class="fa fa-check"></i><b>4.6.2</b> ssm_smooth_update_N</a></li>
<li class="chapter" data-level="4.6.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_size"><i class="fa fa-check"></i><b>4.6.3</b> ssm_smooth_state_size</a></li>
<li class="chapter" data-level="4.6.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_get_mean"><i class="fa fa-check"></i><b>4.6.4</b> ssm_smooth_state_get_mean</a></li>
<li class="chapter" data-level="4.6.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_get_var"><i class="fa fa-check"></i><b>4.6.5</b> ssm_smooth_state_get_var</a></li>
<li class="chapter" data-level="4.6.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state"><i class="fa fa-check"></i><b>4.6.6</b> ssm_smooth_state</a></li>
<li class="chapter" data-level="4.6.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_size"><i class="fa fa-check"></i><b>4.6.7</b> ssm_smooth_eps_size</a></li>
<li class="chapter" data-level="4.6.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_get_mean"><i class="fa fa-check"></i><b>4.6.8</b> ssm_smooth_eps_get_mean</a></li>
<li class="chapter" data-level="4.6.9" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_get_var"><i class="fa fa-check"></i><b>4.6.9</b> ssm_smooth_eps_get_var</a></li>
<li class="chapter" data-level="4.6.10" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps"><i class="fa fa-check"></i><b>4.6.10</b> ssm_smooth_eps</a></li>
<li class="chapter" data-level="4.6.11" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta"><i class="fa fa-check"></i><b>4.6.11</b> ssm_smooth_eta</a></li>
<li class="chapter" data-level="4.6.12" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta_get_mean"><i class="fa fa-check"></i><b>4.6.12</b> ssm_smooth_eta_get_mean</a></li>
<li class="chapter" data-level="4.6.13" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta_get_var"><i class="fa fa-check"></i><b>4.6.13</b> ssm_smooth_eta_get_var</a></li>
<li class="chapter" data-level="4.6.14" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta-1"><i class="fa fa-check"></i><b>4.6.14</b> ssm_smooth_eta</a></li>
<li class="chapter" data-level="4.6.15" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_faststate"><i class="fa fa-check"></i><b>4.6.15</b> ssm_smooth_faststate</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="stan-functions.html"><a href="stan-functions.html#simulators-and-smoothing-simulators"><i class="fa fa-check"></i><b>4.7</b> Simulators and Smoothing Simulators</a><ul>
<li class="chapter" data-level="4.7.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_idx"><i class="fa fa-check"></i><b>4.7.1</b> ssm_sim_idx</a></li>
<li class="chapter" data-level="4.7.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_size"><i class="fa fa-check"></i><b>4.7.2</b> ssm_sim_size</a></li>
<li class="chapter" data-level="4.7.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_y"><i class="fa fa-check"></i><b>4.7.3</b> ssm_sim_get_y</a></li>
<li class="chapter" data-level="4.7.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_a"><i class="fa fa-check"></i><b>4.7.4</b> ssm_sim_get_a</a></li>
<li class="chapter" data-level="4.7.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_eps"><i class="fa fa-check"></i><b>4.7.5</b> ssm_sim_get_eps</a></li>
<li class="chapter" data-level="4.7.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_eta"><i class="fa fa-check"></i><b>4.7.6</b> ssm_sim_get_eta</a></li>
<li class="chapter" data-level="4.7.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_rng"><i class="fa fa-check"></i><b>4.7.7</b> ssm_sim_rng</a></li>
</ul></li>
<li class="chapter" data-level="4.8" data-path="stan-functions.html"><a href="stan-functions.html#simulation-smoothers-1"><i class="fa fa-check"></i><b>4.8</b> Simulation Smoothers</a><ul>
<li class="chapter" data-level="4.8.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_state_rng"><i class="fa fa-check"></i><b>4.8.1</b> ssm_simsmo_state_rng</a></li>
<li class="chapter" data-level="4.8.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eta_rng"><i class="fa fa-check"></i><b>4.8.2</b> ssm_simsmo_eta_rng</a></li>
<li class="chapter" data-level="4.8.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eps_rng"><i class="fa fa-check"></i><b>4.8.3</b> ssm_simsmo_eps_rng</a></li>
</ul></li>
<li class="chapter" data-level="4.9" data-path="stan-functions.html"><a href="stan-functions.html#stationary"><i class="fa fa-check"></i><b>4.9</b> Stationary</a><ul>
<li class="chapter" data-level="4.9.1" data-path="stan-functions.html"><a href="stan-functions.html#pacf_to_acf"><i class="fa fa-check"></i><b>4.9.1</b> pacf_to_acf</a></li>
<li class="chapter" data-level="4.9.2" data-path="stan-functions.html"><a href="stan-functions.html#constrain_stationary"><i class="fa fa-check"></i><b>4.9.2</b> constrain_stationary</a></li>
<li class="chapter" data-level="4.9.3" data-path="stan-functions.html"><a href="stan-functions.html#acf_to_pacf"><i class="fa fa-check"></i><b>4.9.3</b> acf_to_pacf</a></li>
<li class="chapter" data-level="4.9.4" data-path="stan-functions.html"><a href="stan-functions.html#unconstrain_stationary"><i class="fa fa-check"></i><b>4.9.4</b> unconstrain_stationary</a></li>
<li class="chapter" data-level="4.9.5" data-path="stan-functions.html"><a href="stan-functions.html#kronecker_prod"><i class="fa fa-check"></i><b>4.9.5</b> kronecker_prod</a></li>
<li class="chapter" data-level="4.9.6" data-path="stan-functions.html"><a href="stan-functions.html#arima_stationary_cov"><i class="fa fa-check"></i><b>4.9.6</b> arima_stationary_cov</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="other-software.html"><a href="other-software.html"><i class="fa fa-check"></i><b>5</b> Other Software</a><ul>
<li class="chapter" data-level="5.1" data-path="other-software.html"><a href="other-software.html#r-packages"><i class="fa fa-check"></i><b>5.1</b> R packages</a></li>
<li class="chapter" data-level="5.2" data-path="other-software.html"><a href="other-software.html#other"><i class="fa fa-check"></i><b>5.2</b> Other</a><ul>
<li class="chapter" data-level="5.2.1" data-path="other-software.html"><a href="other-software.html#stata"><i class="fa fa-check"></i><b>5.2.1</b> Stata</a></li>
<li class="chapter" data-level="5.2.2" data-path="other-software.html"><a href="other-software.html#python"><i class="fa fa-check"></i><b>5.2.2</b> Python</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">State Space Models in Stan</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="stan-functions" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Stan Functions</h1>
<p>State space functionality for Stan is provided as a set of user-defined functions.</p>
<p>Add the following line to the Stan model file in which depends on these functions.</p>
<pre class="stan"><code>functions {
  #include ssm.stan
  // other functions ...
}</code></pre>
<p>To actually include the functions in the model, you need to use the function <code>stanc_builder</code>, instead of <code>stan</code> or <code>stanc</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span><span class="kw">stanc_builder</span>(<span class="st">&quot;yourmodel.stan&quot;</span>, <span class="dt">isystem =</span> <span class="st">&quot;path/to/ssm/&quot;</span>)
<span class="kw">stan</span>(<span class="dt">model_code =</span> model$model_code)</code></pre></div>
<div id="utility-functions" class="section level2">
<h2><span class="header-section-number">4.1</span> Utility Functions</h2>
<div id="to_symmetric_matrix" class="section level3">
<h3><span class="header-section-number">4.1.1</span> to_symmetric_matrix</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code> <strong>An</strong> <span class="math inline">\(n \times n\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>An</code> <span class="math inline">\(n \times n\)</span> symmetric matrix: <span class="math inline">\(0.5 (x + x&#39;)\)</span>.</p>
<p>Ensure a matrix is symmetrix.</p>
<pre class="stan"><code>matrix to_symmetric_matrix(matrix x) {
  return 0.5 * (x + x &#39;);
}
</code></pre>
</div>
<div id="to_matrix_colwise" class="section level3">
<h3><span class="header-section-number">4.1.2</span> to_matrix_colwise</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>v</strong> An <span class="math inline">\(n \times m\)</span> vector.</li>
<li><code>int</code> <strong>m</strong> Number of rows in the vector</li>
<li><code>int</code> <strong>n</strong> Number of columns in the vector</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(m \times n\)</span> matrix containting the elements from <code>v</code></p>
<p>Convert vector to a matrix (column-major).</p>
<pre class="stan"><code>matrix to_matrix_colwise(vector v, int m, int n) {
  matrix[m, n] res;
  for (j in 1:n) {
    for (i in 1:m) {
      res[i, j] = v[(j - 1) * m + m];
    }
  }
  return res;
}
</code></pre>
</div>
<div id="to_matrix_rowwise" class="section level3">
<h3><span class="header-section-number">4.1.3</span> to_matrix_rowwise</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>v</strong> An <span class="math inline">\(n \times m\)</span> vector.</li>
<li><code>int</code> <strong>m</strong> Number of rows in the matrix.</li>
<li><code>int</code> <strong>n</strong> Number of columns in the matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(m \times n\)</span> matrix containting the elements from <code>v</code></p>
<p>Convert vector to a matrix (row-major).</p>
<pre class="stan"><code>matrix to_matrix_rowwise(vector v, int m, int n) {
  matrix[m, n] res;
  for (i in 1:n) {
    for (j in 1:m) {
      res[i, j] = v[(i - 1) * n + n];
    }
  }
  return res;
}
</code></pre>
</div>
<div id="to_vector_colwise" class="section level3">
<h3><span class="header-section-number">4.1.4</span> to_vector_colwise</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>x</strong> An <span class="math inline">\(n \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> with <span class="math inline">\(n m\)</span> elements.</p>
<p>Convert a matrix to a vector (column-major)</p>
<pre class="stan"><code>vector to_vector_colwise(matrix x) {
  vector[num_elements(x)] res;
  int n;
  int m;
  n = rows(x);
  m = cols(x);
  for (i in 1:n) {
    for (j in 1:m) {
      res[n * (j - 1) + i] = x[i, j];
    }
  }
  return res;
}
</code></pre>
</div>
<div id="to_vector_rowwise" class="section level3">
<h3><span class="header-section-number">4.1.5</span> to_vector_rowwise</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>x</strong> An <span class="math inline">\(n \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> with <span class="math inline">\(n m\)</span> elements.</p>
<p>Convert a matrix to a vector (row-major)</p>
<pre class="stan"><code>vector to_vector_rowwise(matrix x) {
  vector[num_elements(x)] res;
  int n;
  int m;
  n = rows(x);
  m = cols(x);
  for (i in 1:rows(x)) {
    for (j in 1:cols(x)) {
      res[(i - 1) * m + j] = x[i, j];
    }
  }
  return res;
}
</code></pre>
</div>
<div id="symmat_size" class="section level3">
<h3><span class="header-section-number">4.1.6</span> symmat_size</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>x</strong> An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The number of unique elements</p>
<p>Calculate the number of unique elements in a symmetric matrix</p>
<p>The number of unique elements in an <span class="math inline">\(m \times m\)</span> matrix is <span class="math inline">\((m \times (m + 1)) / 2\)</span>.</p>
<pre class="stan"><code>int symmat_size(int n) {
  int sz;
  // This calculates it iteratively because Stan gives a warning
  // with integer division.
  sz = 0;
  for (i in 1:n) {
    sz = sz + i;
  }
  return sz;
}
</code></pre>
</div>
<div id="find_symmat_dim" class="section level3">
<h3><span class="header-section-number">4.1.7</span> find_symmat_dim</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>n</strong> The number of unique elements in a symmetric matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The dimension of the associated symmetric matrix.</p>
<p>Given vector with <span class="math inline">\(n\)</span> elements containing the <span class="math inline">\(m (m + 1) / 2\)</span> elements of a symmetric matrix, return <span class="math inline">\(m\)</span>.</p>
<pre class="stan"><code>int find_symmat_dim(int n) {
  // This could be solved by finding the positive root of $m = m (m + 1)/2 but
  // Stan doesn&#39;t support all the functions necessary to do this.
  int i;
  int remainder;
  i = 0;
  while (n &gt; 0) {
    i = i + 1;
    remainder = remainder - i;
  }
  return i;
}
</code></pre>
</div>
<div id="vector_to_symmat" class="section level3">
<h3><span class="header-section-number">4.1.8</span> vector_to_symmat</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> The vector with the unique elements</li>
<li><code>int</code> <strong>n</strong> The dimensions of the returned matrix: <span class="math inline">\(n \times n\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(n \times n\)</span> symmetric matrix.</p>
<p>Convert a vector to a symmetric matrix</p>
<pre class="stan"><code>matrix vector_to_symmat(vector x, int n) {
  matrix[n, n] m;
  int k;
  k = 1;
  for (j in 1:n) {
    for (i in 1:j) {
      m[i, j] = x[k];
      if (i != j) {
        m[j, i] = m[i, j];
      }
      k = k + 1;
    }
  }
  return m;
}
</code></pre>
</div>
<div id="symmat_to_vector" class="section level3">
<h3><span class="header-section-number">4.1.9</span> symmat_to_vector</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> An <span class="math inline">\(n \times n\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(n (n + 1) / 2\)</span> vector with the unique elements in <span class="math inline">\(x\)</span>.</p>
<p>Convert an <span class="math inline">\(n \times n\)</span> symmetric matrix to a length <span class="math inline">\(n (n + 1) / 2\)</span> vector containing its unique elements.</p>
<pre class="stan"><code>vector symmat_to_vector(matrix x) {
  vector[symmat_size(rows(x))] v;
  int k;
  k = 1;
  // if x is m x n symmetric, then this will return
  // only parts of an m x m matrix.
  for (j in 1:rows(x)) {
    for (i in 1:j) {
      v[k] = x[i, j];
      k = k + 1;
    }
  }
  return v;
}</code></pre>
</div>
</div>
<div id="filtering-1" class="section level2">
<h2><span class="header-section-number">4.2</span> Filtering</h2>
<p>Functions used in filtering and log-likelihood calculations.</p>
<div id="ssm_filter_update_a" class="section level3">
<h3><span class="header-section-number">4.2.1</span> ssm_filter_update_a</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>a</strong> An <span class="math inline">\(m \times 1\)</span> vector with the prected state, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>vector</code> <strong>c</strong> An <span class="math inline">\(m \times 1\)</span> vector with the system intercept, <span class="math inline">\(\vec{c}_t\)</span></li>
<li><code>matrix</code> <strong>T</strong> An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>vector</code> <strong>v</strong> A <span class="math inline">\(p \times 1\)</span> vector with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>matrix</code> <strong>K</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(m \times 1\)</span> vector with the predicted state at <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\vec{a}_{t + 1}\)</span>.</p>
<p>Update the expected value of the predicted state, <span class="math inline">\(\vec{a}_{t + 1} = \E(\vec{\alpha}_{t + 1} | \vec{y}_{1:t})\)</span>,</p>
<p>The predicted state <span class="math inline">\(\vec{a}_{t + 1}\)</span> is, <span class="math display">\[
\vec{a}_{t + 1} = \mat{T}_t \vec{a}_t + \mat{K}_t \vec{v}_t + \vec{c}_t .
\]</span></p>
<pre class="stan"><code>vector ssm_filter_update_a(vector a, vector c, matrix T, vector v, matrix K) {
  vector[num_elements(a)] a_new;
  a_new = T * a + K * v + c;
  return a_new;
}
</code></pre>
</div>
<div id="ssm_filter_update_p" class="section level3">
<h3><span class="header-section-number">4.2.2</span> ssm_filter_update_P</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>P</strong> An <span class="math inline">\(m \times m\)</span> vector with the variance of the prected state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>matrix</code> <strong>T</strong> An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>matrix</code> <strong>RQR</strong> A <span class="math inline">\(m \times m\)</span> matrix with the system covariance matrix, <span class="math inline">\(\mat{R}_t \mat{Q}_t \mat{R}_t&#39;\)</span>.</li>
<li><code>matrix</code> <strong>K</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times 1\)</span> vector with the predicted state at <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\vec{a}_{t + 1}\)</span>.</p>
<p>Update the expected value of the predicted state, <span class="math inline">\(\mat{P}_{t + 1} = \Var(\alpha_{t + 1} | \vec{y}_{1:t})\)</span>,</p>
<p>The predicted state variance <span class="math inline">\(\mat{P}_{t + 1}\)</span> is, <span class="math display">\[
\mat{P}_{t + 1} = \mat{T}_t \mat{P}_t (\mat{T}_t - \mat{K}_t \mat{Z}_t)&#39; + \mat{R}_t \mat{Q}_t \mat{R}_t&#39; .
\]</span></p>
<pre class="stan"><code>matrix ssm_filter_update_P(matrix P, matrix Z, matrix T,
                           matrix RQR, matrix K) {
  matrix[rows(P), cols(P)] P_new;
  P_new = to_symmetric_matrix(T * P * (T - K * Z)&#39; + RQR);
  return P_new;
}
</code></pre>
</div>
<div id="ssm_filter_update_v" class="section level3">
<h3><span class="header-section-number">4.2.3</span> ssm_filter_update_v</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>P</strong> An <span class="math inline">\(m \times m\)</span> vector with the variance of the prected state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>matrix</code> <strong>T</strong> An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>matrix</code> <strong>RQR</strong> An <span class="math inline">\(m \times m\)</span> matrix with the system covariance matrix, <span class="math inline">\(\mat{R}_t \mat{Q}_t \mat{R}_t&#39;\)</span>.</li>
<li><code>matrix</code> <strong>K</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> An <span class="math inline">\(m \times 1\)</span> vector with the predicted state at <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\vec{a}_{t + 1}\)</span>.</p>
<p>Update the forcast error, <span class="math inline">\(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}})\)</span></p>
<p>The forecast error <span class="math inline">\(\vec{v}_t\)</span> is <span class="math display">\[
\vec{v}_t =\vec{y}_t - \mat{Z}_t \vec{a}_t - \vec{d}_t .
\]</span></p>
<pre class="stan"><code>vector ssm_filter_update_v(vector y, vector a, vector d, matrix Z) {
  vector[num_elements(y)] v;
  v = y - Z * a - d;
  return v;
}
</code></pre>
</div>
<div id="ssm_filter_update_f" class="section level3">
<h3><span class="header-section-number">4.2.4</span> ssm_filter_update_F</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>P</strong> An <span class="math inline">\(m \times m\)</span> vector with the variance of the prected state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>matrix</code> <strong>H</strong> A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}_t\)</span>.</p>
<p>Update the variance of the forcast error, <span class="math inline">\(\mat{F}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))\)</span></p>
<p>The variance of the forecast error <span class="math inline">\(\mat{F}_t\)</span> is <span class="math display">\[
\mat{F}_t = \mat{Z}_t \mat{P}_t \mat{Z}_t + \mat{H}_t .
\]</span></p>
<pre class="stan"><code>matrix ssm_filter_update_F(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] F;
  F = quad_form(P, Z&#39;) + H;
  return F;
}
</code></pre>
</div>
<div id="ssm_filter_update_finv" class="section level3">
<h3><span class="header-section-number">4.2.5</span> ssm_filter_update_Finv</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>P</strong> An <span class="math inline">\(m \times m\)</span> vector with the variance of the prected state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>matrix</code> <strong>H</strong> A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Update the precision of the forcast error, <span class="math inline">\(\mat{F}^{-1}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))^{-1}\)</span></p>
<p>This is the inverse of <span class="math inline">\(\mat{F}_t\)</span>.</p>
<pre class="stan"><code>matrix ssm_filter_update_Finv(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] Finv;
  Finv = inverse(ssm_filter_update_F(P, Z, H));
  return Finv;
}
</code></pre>
</div>
<div id="ssm_filter_update_k" class="section level3">
<h3><span class="header-section-number">4.2.6</span> ssm_filter_update_K</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>P</strong> An <span class="math inline">\(m \times m\)</span> vector with the variance of the prected state, <span class="math inline">\(P_t\)</span>.</li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>matrix</code> <strong>T</strong> An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>matrix</code> <strong>Finv</strong> A <span class="math inline">\(p \times p\)</span> matrix</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>Update the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>The Kalman gain is <span class="math display">\[
\mat{K}_t = \mat{T}_t \mat{P}_t \mat{Z}_t&#39; \mat{F}^{-1}_t .
\]</span></p>
<pre class="stan"><code>matrix ssm_filter_update_K(matrix P, matrix Z, matrix T, matrix Finv) {
  matrix[cols(Z), rows(Z)] K;
  K = T * P * Z&#39; * Finv;
  return K;
}
</code></pre>
</div>
<div id="ssm_filter_update_l" class="section level3">
<h3><span class="header-section-number">4.2.7</span> ssm_filter_update_L</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span></li>
<li><code>matrix</code> <strong>T</strong> An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>matrix</code> <strong>K</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix, <span class="math inline">\(\mat{L}_t\)</span>.</p>
<p>Update <span class="math inline">\(L_t\)</span></p>
<p><span class="math display">\[
\mat{L}_t = \mat{T}_t - \mat{K}_t \mat{Z}_t .
\]</span></p>
<pre class="stan"><code>matrix ssm_filter_update_L(matrix Z, matrix T, matrix K) {
  matrix[rows(T), cols(T)] L;
  L = T - K * Z;
  return L;
}
</code></pre>
</div>
<div id="ssm_filter_update_ll" class="section level3">
<h3><span class="header-section-number">4.2.8</span> ssm_filter_update_ll</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>v</strong> A <span class="math inline">\(p \times 1\)</span> matrix with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>matrix</code> <strong>Finv</strong> A <span class="math inline">\(p \times p\)</span> matrix with variance of the forecast error, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>real</code> An <span class="math inline">\(m \times m\)</span> matrix, <span class="math inline">\(L_t\)</span>.</p>
<p>Calculate the log-likelihood for a period</p>
<p>The log-likehood of a single observation in a state-space model is <span class="math display">\[
\ell_t = - \frac{1}{2} p \log(2 \pi) - \frac{1}{2} \left(\log|\mat{F}_t| + \vec{v}_t&#39; \mat{F}^{-1}_t \vec{v}_t  \right)
\]</span></p>
<pre class="stan"><code>real ssm_filter_update_ll(vector v, matrix Finv) {
  real ll;
  int p;
  p = num_elements(v);
  // det(A^{-1}) = 1 / det(A) -&gt; log det(A^{-1}) = - log det(A)
  ll = (- 0.5 *
        (p * log(2 * pi())
         - log_determinant(Finv)
         + quad_form(Finv, v)
       ));
  return ll;
}
</code></pre>
</div>
</div>
<div id="filtering-2" class="section level2">
<h2><span class="header-section-number">4.3</span> Filtering</h2>
<div id="ssm_filter_idx" class="section level3">
<h3><span class="header-section-number">4.3.1</span> ssm_filter_idx</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>int[,]</code> A <span class="math inline">\(6 \times 3\)</span> integer array containing the indexes of the return values of the Kalman filter.</p>
<p>Indexes of the return values of the Kalman filter functions: <code>ssm_filter</code>.</p>
<p><code>ssm_filter_idx</code> returns a <span class="math inline">\(6 \times 3\)</span> integer array with the (length, start index, stop index) of (<span class="math inline">\(\ell_t\)</span>, <span class="math inline">\(\vec{v}\)</span>, <span class="math inline">\(\vec{F}^-1\)</span>, <span class="math inline">\(\mat{K}\)</span>, <span class="math inline">\(\vec{a}\)</span>, <span class="math inline">\(\mat{P}\)</span>).</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">stop</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\ell_t\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\vec{v}\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(2\)</span></td>
<td align="left"><span class="math inline">\(1 + p\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mat{F}^{-1}\)</span></td>
<td align="left"><span class="math inline">\(p (p + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(2 + p\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{K}\)</span></td>
<td align="left"><span class="math inline">\(mp\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\vec{a}_t\)</span></td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2 + mp\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp + m\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{P}^t\)</span></td>
<td align="left"><span class="math inline">\(m (m + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2 + mp + m\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp + m (m + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<pre class="stan"><code>int[,] ssm_filter_idx(int m, int p) {
  int sz[6, 3];
  // loglike
  sz[1, 1] = 1;
  // v
  sz[2, 1] = p;
  // Finv
  sz[3, 1] = symmat_size(p);
  // K
  sz[4, 1] = m * p;
  // a
  sz[5, 1] = m;
  // P
  sz[6, 1] = symmat_size(m);
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:6) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}
</code></pre>
</div>
<div id="ssm_filter_size" class="section level3">
<h3><span class="header-section-number">4.3.2</span> ssm_filter_size</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The number of elements in the vector.</p>
<p>Number of elements in vector containing filter results</p>
<pre class="stan"><code>int ssm_filter_size(int m, int p) {
  int sz;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  sz = idx[6, 3];
  return sz;
}
</code></pre>
</div>
<div id="ssm_filter_get_loglik" class="section level3">
<h3><span class="header-section-number">4.3.3</span> ssm_filter_get_loglik</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>real</code> The log-likelihood <span class="math inline">\(\ell_t\)</span></p>
<p>Get the log-likehood from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>real ssm_filter_get_loglik(vector x, int m, int p) {
  real y;
  y = x[1];
  return y;
}
</code></pre>
</div>
<div id="ssm_filter_get_v" class="section level3">
<h3><span class="header-section-number">4.3.4</span> ssm_filter_get_v</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(p \times 1\)</span> vector with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</p>
<p>Get the forecast error from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>vector ssm_filter_get_v(vector x, int m, int p) {
  vector[p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[2, 2], idx[2, 3]);
  return y;
}
</code></pre>
</div>
<div id="ssm_filter_get_finv" class="section level3">
<h3><span class="header-section-number">4.3.5</span> ssm_filter_get_Finv</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(p \times p\)</span> matrix with the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Get the forecast precision from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>matrix ssm_filter_get_Finv(vector x, int m, int p) {
  matrix[p, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[3, 2], idx[3, 3]), p);
  return y;
}
</code></pre>
</div>
<div id="ssm_filter_get_k" class="section level3">
<h3><span class="header-section-number">4.3.6</span> ssm_filter_get_K</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Get the Kalman gain from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>matrix ssm_filter_get_K(vector x, int m, int p) {
  matrix[m, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = to_matrix_colwise(segment(x, idx[4, 2], idx[4, 3]), m, p);
  return y;
}
</code></pre>
</div>
<div id="ssm_filter_get_a" class="section level3">
<h3><span class="header-section-number">4.3.7</span> ssm_filter_get_a</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> An <span class="math inline">\(m \times 1\)</span> vector with the expected value of the predicted state, <span class="math inline">\(\E(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \vec{a}_t\)</span>.</p>
<p>Get the expected value of the predicted state from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>vector ssm_filter_get_a(vector x, int m, int p) {
  vector[m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[5, 2], idx[5, 3]);
  return y;
}
</code></pre>
</div>
<div id="ssm_filter_get_p" class="section level3">
<h3><span class="header-section-number">4.3.8</span> ssm_filter_get_P</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>A</strong> vector with results from <code>ssm_filter</code>.</li>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix with the variance of the predicted state, <span class="math inline">\(\Var(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \mat{P}_t\)</span>.</p>
<p>Get the variance of the predicted state from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>matrix ssm_filter_get_P(vector x, int m, int p) {
  matrix[m, m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[6, 2], idx[6, 3]), m);
  return y;
}
</code></pre>
</div>
<div id="ssm_filter" class="section level3">
<h3><span class="header-section-number">4.3.9</span> ssm_filter</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>y</strong> Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\((1 + p + p (p + 1) / 2 + mp + m + m (m + 1) / 2) \times 1\)</span> vectors in the format described in <code>ssm_filter_idx</code>.</p>
<p>Kalman filter</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p><code>ssm_filter</code> runs a forward filter on the state space model and calculates,</p>
<ul>
<li>log-likelihood for each observation, <span class="math inline">\(\ell_t\)</span>.</li>
<li>Forecast error, <span class="math inline">\(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
<li>Forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li>Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
<li>Predicted states, <span class="math inline">\(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
<li>Variance of the predicted states, <span class="math inline">\(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
</ul>
<p>The results of Kalman filter for a given are returned as a <span class="math inline">\(1 + p + p (p + 1) / 2 + m p + m (m + 1) / 2\)</span> vector for each time period, where <span class="math display">\[
(\ell_t, \vec{v}_t&#39;, \VEC(\mat{F}^{-1}_t)&#39;, \VEC(\mat{K}_t)&#39;, \vec{a}_t&#39;, \VEC(\mat{P}_t)&#39; )&#39;.
\]</span></p>
<pre class="stan"><code>vector[] ssm_filter(vector[] y,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {

  // returned data
  vector[ssm_filter_size(dims(Z)[3], dims(Z)[2])] res[size(y)];
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  p = dims(Z)[2]; // obs size
  m = dims(Z)[3]; // number of states
  q = dims(Q)[2]; // number of state disturbances

  //print(&quot;Sizes: n = &quot;, m, &quot;, p = &quot;, n, &quot;, m = &quot;, m, &quot;, q = &quot;, q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    real ll;
    int idx[6, 3];

    idx = ssm_filter_idx(m, p);

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form(Q_t, R_t);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 &amp;&amp; size(Q) &gt; 1) {
          RQR = quad_form(Q_t, R_t);
        }
      }
      // updating
      v = ssm_filter_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_filter_update_Finv(P, Z_t, H_t);
      K = ssm_filter_update_K(P, T_t, Z_t, Finv);
      ll = ssm_filter_update_ll(v, Finv);
      // saving
      res[t, 1] = ll;
      res[t, idx[2, 2]:idx[2, 3]] = v;
      res[t, idx[3, 2]:idx[3, 3]] = symmat_to_vector(Finv);
      res[t, idx[4, 2]:idx[4, 3]] = to_vector(K);
      res[t, idx[5, 2]:idx[5, 3]] = a;
      res[t, idx[6, 2]:idx[6, 3]] = symmat_to_vector(P);
      // predict a_{t + 1}, P_{t + 1}
      if (t &lt; n) {
        a = ssm_filter_update_a(a, c_t, T_t, v, K);
        P = ssm_filter_update_P(P, Z_t, T_t, RQR, K);
      }
    }
  }
  return res;
}
</code></pre>
</div>
<div id="ssm_filter_states" class="section level3">
<h3><span class="header-section-number">4.3.10</span> ssm_filter_states</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> Number of states</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The size of the vector</p>
<p>Length of the vectors returned by <code>ssm_filter_states</code></p>
<pre class="stan"><code>int ssm_filter_states_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}
</code></pre>
</div>
<div id="ssm_filter_states_get_a" class="section level3">
<h3><span class="header-section-number">4.3.11</span> ssm_filter_states_get_a</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_filter_states</code></li>
<li><code>int</code> <strong>m</strong> Number of states</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times 1\)</span> vector with the filtered expected value of the state, <span class="math inline">\(\vec{a}_{t|t} = \E(\vec{\alpha}_t | \vec{y}_{1:t})\)</span>.</p>
<p>Extract <span class="math inline">\(a_{t|t}\)</span> from the results of <code>ssm_filter_states</code></p>
<pre class="stan"><code>vector ssm_filter_states_get_a(vector x, int m) {
  vector[m] a;
  a = x[ :m];
  return a;
}
</code></pre>
</div>
<div id="ssm_filter_states_get_p" class="section level3">
<h3><span class="header-section-number">4.3.12</span> ssm_filter_states_get_P</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_filter_states</code></li>
<li><code>int</code> <strong>m</strong> Number of states</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix with the filtered variance of the state, <span class="math inline">\(\mat{P}_{t|t} = \Var(\vec{\alpha}_t | \vec{y}_{1:t})\)</span>.</p>
<p>Extract <span class="math inline">\(P_{t|t}\)</span> from the results of <code>ssm_filter_states</code></p>
<pre class="stan"><code>matrix ssm_filter_states_get_P(vector x, int m) {
  matrix[m, m] P;
  P = vector_to_symmat(x[(m + 1): ], m);
  return P;
}
</code></pre>
</div>
<div id="ssm_filter_states-1" class="section level3">
<h3><span class="header-section-number">4.3.13</span> ssm_filter_states</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>filter</strong> Results from <code>ssm_filter</code></li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
</ul>
<p><strong>Return Value:</strong> <code>Array</code> of size <span class="math inline">\(n\)</span> of vectors.</p>
<p>Calculate filtered expected values and variances of the states</p>
<p>The filtering function <code>ssm_filter</code> returns the mean and variance of the predicted states, <span class="math inline">\(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span> and <span class="math inline">\(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</p>
<p>The vectors returned by <code>ssm_filter_states</code> are of length <span class="math inline">\(m + m ^ 2\)</span>, with <span class="math display">\[
\vec{v}_t = (\vec{a}_{t|t}&#39;, \VEC(\vec{P}_{t|t})&#39; )&#39;
\]</span> Use the functions <code>ssm_filter_states_get_a</code> and <code>ssm_filter_states_get_P</code> to extract elements from the results.</p>
<p>For <code>Z</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n - 1\)</span> if it is time varying.</p>
<pre class="stan"><code>vector[] ssm_filter_states(vector[] filter, matrix[] Z) {
  vector[ssm_filter_states_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    // filter matrices
    vector[m] aa; // filtered values of the state, a_{t|t}
    matrix[m, m] PP; // filtered values of the variance of the state, P_{t|t}
    vector[p] v;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    Z_t = Z[1];
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
      }
      // extract values from the filter
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // calcualte filtered values
      aa = a + P * Z_t &#39; * Finv * v;
      PP = to_symmetric_matrix(P - P * quad_form(Finv, Z_t) * P);
      // saving
      res[t, :m] = aa;
      res[t, (m + 1): ] = symmat_to_vector(PP);
    }
  }
  return res;
}
</code></pre>
</div>
</div>
<div id="log-likelihood" class="section level2">
<h2><span class="header-section-number">4.4</span> Log-likelihood</h2>
<div id="ssm_lpdf" class="section level3">
<h3><span class="header-section-number">4.4.1</span> ssm_lpdf</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>y</strong> Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>real</code> The log-likelihood, <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\)</span>, marginalized over the latent states.</p>
<p>Log-likelihood of a Linear Gaussian State Space Model</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>The log-likelihood of a linear Gaussian state space model is, If the the system matrices and initial conditions are known, the log likelihood is <span class="math display">\[
\begin{aligned}[t]
\log L(\mat{Y}_n) &amp;= \log p(\vec{y}_1, \dots, \vec{y}_n) = \sum_{t = 1}^n \log p(\vec{y}_t | \mat{Y}_{t - 1}) \\
&amp;= - \frac{np}{2} \log 2 \pi - \frac{1}{2} \sum_{t = 1}^n \left( \log \left| \mat{F}_t \right| + \vec{v}\T \mat{F}_t^{-1} \vec{v}_t \right)
\end{aligned} ,
\]</span> where <span class="math inline">\(\mat{F}_t\)</span> and <span class="math inline">\(\mat{V}_t\)</span> come from a forward pass of the Kalman filter.</p>
<pre class="stan"><code>real ssm_lpdf(vector[] y,
               vector[] d, matrix[] Z, matrix[] H,
               vector[] c, matrix[] T, matrix[] R, matrix[] Q,
               vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;
  int q;
  n = size(y); // number of obs
  m = dims(Z)[2];
  p = dims(Z)[3];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form(Q_t, R_t);

    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 &amp;&amp; size(Q) &gt; 1) {
          RQR = quad_form(Q_t, R_t);
        }
      }
      v = ssm_filter_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_filter_update_Finv(P, Z_t, H_t);
      K = ssm_filter_update_K(P, Z_t, T_t, Finv);
      ll_obs[t] = ssm_filter_update_ll(v, Finv);
      // don&#39;t save a, P for last iteration
      if (t &lt; n) {
        a = ssm_filter_update_a(a, c_t, T_t, v, K);
        P = ssm_filter_update_P(P, Z_t, T_t, RQR, K);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}
</code></pre>
</div>
</div>
<div id="time-invariant-kalman-filter" class="section level2">
<h2><span class="header-section-number">4.5</span> Time-Invariant Kalman Filter</h2>
<div id="ssm_check_matrix_equal" class="section level3">
<h3><span class="header-section-number">4.5.1</span> ssm_check_matrix_equal</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>A</strong> An <span class="math inline">\(m \times n\)</span> matrix.</li>
<li><code>matrix</code> <strong>B</strong> An <span class="math inline">\(m \times n\)</span> matrix.</li>
<li><code>real</code> <strong>The</strong> relative tolerance for convergence.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> If converged, then 1, else 0.</p>
<p>Check if two matrices are approximately equal</p>
<p>The matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are considered approximately equal if <span class="math display">\[
\max(A - B) / \max(A) &lt; \epsilon,
\]</span> where <span class="math inline">\(\epsilon\)</span> is the tolerance.</p>
<pre class="stan"><code>int ssm_check_matrix_equal(matrix A, matrix B, real tol) {
  real eps;
  eps = max(to_vector(A - B)) / max(to_vector(A));
  if (eps &lt; tol) {
    return 1;
  } else {
    return 0;
  }
}
</code></pre>
</div>
<div id="ssm_constant_lpdf" class="section level3">
<h3><span class="header-section-number">4.5.2</span> ssm_constant_lpdf</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>y</strong> Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>vector</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>real</code> The log-likelihood, <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\)</span>, marginalized over the latent states.</p>
<p>Log-likelihood of a Time-Invariant Linear Gaussian State Space Model</p>
<p>Unlike <code>ssm_filter</code>, this function requires the system matrices (<code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) to all be time invariant (constant). When the state space model is time-invariant, then the Kalman recursion for <span class="math inline">\(\mat{P}_t\)</span> converges. This function takes advantage of this feature and stops updating <span class="math inline">\(\mat{P}_t\)</span> after it converges to a steady state.</p>
<pre class="stan"><code>real ssm_constant_lpdf(vector[] y,
                      vector d, matrix Z, matrix H,
                      vector c, matrix T, matrix R, matrix Q,
                      vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;

  n = size(y); // number of obs
  m = cols(Z);
  p = rows(Z);
  {
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    matrix[m, m] RQR;
    // indicator for if the filter has converged
    // This only works for time-invariant state space models
    int converged;
    matrix[m, m] P_old;
    real tol;
    converged = 0;
    tol = 1e-7;

    RQR = quad_form(Q, R);
    a = a1;
    P = P1;
    for (t in 1:n) {
      v = ssm_filter_update_v(y[t], a, d, Z);
      if (converged &lt; 1) {
        Finv = ssm_filter_update_Finv(P, Z, H);
        K = ssm_filter_update_K(P, Z, T, Finv);
      }
      ll_obs[t] = ssm_filter_update_ll(v, Finv);
      // don&#39;t save a, P for last iteration
      if (t &lt; n) {
        a = ssm_filter_update_a(a, c, T, v, K);
        // check for convergence
        // should only check for convergence if there are no missing values
        if (converged &lt; 1) {
          P_old = P;
          P = ssm_filter_update_P(P, Z, T, RQR, K);
          converged = ssm_check_matrix_equal(P, P_old, tol);
        }
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}


</code></pre>
</div>
</div>
<div id="common-smoother-functions" class="section level2">
<h2><span class="header-section-number">4.6</span> Common Smoother Functions</h2>
<div id="ssm_smooth_update_r" class="section level3">
<h3><span class="header-section-number">4.6.1</span> ssm_smooth_update_r</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>r</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t-1}\)</span></li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> vector with <span class="math inline">\(\mat{Z}_{t}\)</span></li>
<li><code>vector</code> <strong>v</strong> A <span class="math inline">\(p \times 1\)</span> vector of the forecast errors, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>matrix</code> <strong>Finv</strong> A <span class="math inline">\(p \times p\)</span> matrix of the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li><code>matrix</code> <strong>L</strong> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_t\)</span>.</p>
<p>Update <span class="math inline">\(\vec{r}_t\)</span> in smoothing recursions</p>
<p>In smoothing recursions, the vector <span class="math inline">\(\vec{r}_t\)</span> is updated with, <span class="math display">\[
\vec{r}_{t - 1} = \mat{Z}&#39; \mat{F}^{-1}_t \vec{v}_t + \mat{L}&#39; \vec{r}_{t} .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, 91)</span></p>
<pre class="stan"><code>vector ssm_smooth_update_r(vector r, matrix Z, vector v, matrix Finv,
                           matrix L) {
  vector[num_elements(r)] r_new;
  r_new = Z &#39; * Finv * v + L &#39; * r;
  return r_new;
}
</code></pre>
</div>
<div id="ssm_smooth_update_n" class="section level3">
<h3><span class="header-section-number">4.6.2</span> ssm_smooth_update_N</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>N</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{N}_{t-1}\)</span></li>
<li><code>matrix</code> <strong>Z</strong> A <span class="math inline">\(p \times m\)</span> vector with <span class="math inline">\(\mat{Z}_{t}\)</span></li>
<li><code>matrix</code> <strong>Finv</strong> A <span class="math inline">\(p \times p\)</span> matrix of the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li><code>matrix</code> <strong>L</strong> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\vec{N}_t\)</span>.</p>
<p>Update <span class="math inline">\(\mat{N}_t\)</span> in smoothing recursions</p>
<p>In smoothing recursions, the matrix <span class="math inline">\(\vec{N}_t\)</span> is updated with, <span class="math display">\[
\mat{N}_{t - 1} = \mat{Z}_t&#39; \mat{F}^{-1}_t \mat{Z}_t + \mat{L}_t&#39; \mat{N}_t \mat{L}_t .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, 91)</span></p>
<pre class="stan"><code>matrix ssm_smooth_update_N(matrix N, matrix Z, matrix Finv, matrix L) {
  matrix[rows(N), cols(N)] N_new;
  N_new = quad_form(Finv, Z) + quad_form(N, L);
  return N_new;
}

</code></pre>
</div>
<div id="ssm_smooth_state_size" class="section level3">
<h3><span class="header-section-number">4.6.3</span> ssm_smooth_state_size</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The size of the vectors is <span class="math inline">\(m + m (m + 1) / 2\)</span>.</p>
<p>The number of elements in vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>int ssm_smooth_state_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}
</code></pre>
</div>
<div id="ssm_smooth_state_get_mean" class="section level3">
<h3><span class="header-section-number">4.6.4</span> ssm_smooth_state_get_mean</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_smooth_state</code></li>
<li><code>int</code> <strong>q</strong> The number of state disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\eta}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span> from vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>vector ssm_smooth_state_get_mean(vector x, int m) {
  vector[m] alpha;
  alpha = x[ :m];
  return alpha;
}
</code></pre>
</div>
<div id="ssm_smooth_state_get_var" class="section level3">
<h3><span class="header-section-number">4.6.5</span> ssm_smooth_state_get_var</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_smooth_state</code></li>
<li><code>int</code> <strong>m</strong> The number of states</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{V}_t\)</span>.</p>
<p>Extract <span class="math inline">\(mat{V}_t\)</span> from vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>matrix ssm_smooth_state_get_var(vector x, int m) {
  matrix[m, m] V;
  V = vector_to_symmat(x[(m + 1): ], m);
  return V;
}

</code></pre>
</div>
<div id="ssm_smooth_state" class="section level3">
<h3><span class="header-section-number">4.6.6</span> ssm_smooth_state</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>filter</strong> Results of <code>ssm_filter</code></li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> An array of vectors constaining <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span> and <span class="math inline">\(\mat{V}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:n})\)</span>.</p>
<p>The state smoother</p>
<p>This calculates the mean and variance of the states, <span class="math inline">\(\vec{\alpha}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>in the format described below.</p>
<p>For <code>Z</code> and <code>T</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>) if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(m + m ^ 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\alpha}}_t&#39;, \VEC(\mat{V}_t)&#39; )&#39;.
\]</span> Use the <code>ssm_smooth_state_get_mean</code> and <code>ssm_smooth_state_get_var</code> to extract components from the returned vectors.</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\alpha}}_t\)</span></td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(m\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{V}_t\)</span></td>
<td align="left"><span class="math inline">\(m (m + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(m + 1\)</span></td>
<td align="left"><span class="math inline">\(m + m (m + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<p>See <span class="citation">Durbin and Koopman (<a href="#ref-DurbinKoopman2012">2012</a>)</span>, Eq 4.44 and eq 4.69.</p>
<pre class="stan"><code>vector[] ssm_smooth_state(vector[] filter, matrix[] Z, matrix[] T) {
  vector[ssm_smooth_state_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    // smoother results
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[m] alpha;
    matrix[m, m] V;
    // filter results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    // move backwards in time: t, ..., 1
    for (i in 0:(n - 1)) {
      int t;
      t = n - i;
      // set time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get filtered values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // updating
      // L_t
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      // hat(alpha)_{t} and V_t which use r and N from (t - 1)
      alpha = a + P * r;
      V = to_symmetric_matrix(P - P * N * P);
      // saving
      res[t, :m] = alpha;
      res[t, (m + 1): ] = symmat_to_vector(V);
    }
  }
  return res;
}

</code></pre>
</div>
<div id="ssm_smooth_eps_size" class="section level3">
<h3><span class="header-section-number">4.6.7</span> ssm_smooth_eps_size</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>p</strong> The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The size of the vectors is <span class="math inline">\(p + p (p + 1) / 2\)</span>.</p>
<p>The size of the vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>int ssm_smooth_eps_size(int p) {
  int sz;
  sz = p + symmat_size(p);
  return sz;
}
</code></pre>
</div>
<div id="ssm_smooth_eps_get_mean" class="section level3">
<h3><span class="header-section-number">4.6.8</span> ssm_smooth_eps_get_mean</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code> <strong>A</strong> vector from the results of <code>ssm_smooth_eps</code>.</li>
<li><code>int</code> <strong>p</strong> The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> from vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>vector ssm_smooth_eps_get_mean(vector x, int p) {
  vector[p] eps;
  eps = x[ :p];
  return eps;
}
</code></pre>
</div>
<div id="ssm_smooth_eps_get_var" class="section level3">
<h3><span class="header-section-number">4.6.9</span> ssm_smooth_eps_get_var</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_smooth_eps</code></li>
<li><code>int</code> <strong>p</strong> The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(p \times p\)</span> matrix with <span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span></p>
<p>Extract <span class="math inline">\(\Var(\varepsilon_t|\vec{y}_{1:n})\)</span> from vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>matrix ssm_smooth_eps_get_var(vector x, int p) {
  matrix[p, p] eps_var;
  eps_var = vector_to_symmat(x[(p + 1): ], p);
  return eps_var;
}
</code></pre>
</div>
<div id="ssm_smooth_eps" class="section level3">
<h3><span class="header-section-number">4.6.10</span> ssm_smooth_eps</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>filter</strong> Results of <code>ssm_filter</code></li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> An array of vectors constaining <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> and <span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span> in the format described below.</p>
<p>The observation disturbance smoother</p>
<p>This calculates the mean and variance of the observation disturbances, <span class="math inline">\(\vec{\varepsilon}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>For Z<code>,</code>H<code>, T</code>, the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>), if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(p + p (p + 1) / 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\varepsilon}}_t&#39;, \VEC(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n}))&#39; )&#39;
\]</span></p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span></td>
<td align="left"><span class="math inline">\(p (p + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(p + 1\)</span></td>
<td align="left"><span class="math inline">\(p + p (p + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>vector[] ssm_smooth_eps(vector[] filter, matrix[] Z, matrix[] H, matrix[] T) {
  vector[ssm_smooth_eps_size(dims(Z)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // smoother values
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[p] eps;
    matrix[p, p] var_eps;
    // filter results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    matrix[m, m] T_t;

    // set matrices if time-invariant
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(H) == 1) {
      H_t = H[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 1:n) {
      int t;
      // move backwards in time
      t = n - i + 1;
      // update time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(H) &gt; 1) {
        H_t = H[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      // eps_t and V(eps_t|y)
      eps = H_t * (Finv * v - K &#39; * r);
      var_eps = to_symmetric_matrix(H_t - H_t * (Finv + quad_form(N, K)) * H_t);
      // saving
      res[t, :p] = eps;
      res[t, (p + 1): ] = symmat_to_vector(var_eps);
    }
  }
  return res;
}
</code></pre>
</div>
<div id="ssm_smooth_eta" class="section level3">
<h3><span class="header-section-number">4.6.11</span> ssm_smooth_eta</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>p</strong> The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The size of the vectors is <span class="math inline">\(q + q (q + 1) / 2\)</span>.</p>
<p>The size of the vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>int ssm_smooth_eta_size(int q) {
  int sz;
  sz = q + symmat_size(q);
  return sz;
}
</code></pre>
</div>
<div id="ssm_smooth_eta_get_mean" class="section level3">
<h3><span class="header-section-number">4.6.12</span> ssm_smooth_eta_get_mean</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_smooth_eta</code></li>
<li><code>int</code> <strong>q</strong> The number of state disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(q \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\eta}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> from vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>vector ssm_smooth_eta_get_mean(vector x, int q) {
  vector[q] eta;
  eta = x[ :q];
  return eta;
}
</code></pre>
</div>
<div id="ssm_smooth_eta_get_var" class="section level3">
<h3><span class="header-section-number">4.6.13</span> ssm_smooth_eta_get_var</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector returned by <code>ssm_smooth_eta</code></li>
<li><code>int</code> <strong>q</strong> The number of state disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> A <span class="math inline">\(q \times q\)</span> matrix with <span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span>.</p>
<p>Extract <span class="math inline">\(\Var(\eta_t|\vec{y}_{1:n})\)</span> from vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>matrix ssm_smooth_eta_get_var(vector x, int q) {
  matrix[q, q] eta_var;
  eta_var = vector_to_symmat(x[(q + 1): ], q);
  return eta_var;
}
</code></pre>
</div>
<div id="ssm_smooth_eta-1" class="section level3">
<h3><span class="header-section-number">4.6.14</span> ssm_smooth_eta</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>filter</strong> Results of <code>ssm_filter</code></li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> An array of vectors constaining <span class="math inline">\(\hat{\vec{\eta}}_t\)</span> and <span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span> in the format described below.</p>
<p>The state disturbance smoother</p>
<p>This calculates the mean and variance of the observation disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>For <code>Z</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(q + q (q + 1) / 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\eta}}_t&#39;, \VEC(\Var(\vec{\eta}_t | \vec{y}_{1:n}))&#39; ).
\]</span> Use the <code>ssm_smooth_eta_get_mean</code> and <code>ssm_smooth_eta_get_var</code> to extract components from the returned vectors.</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\eta}}_t\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span></td>
<td align="left"><span class="math inline">\(q (q + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(q + 1\)</span></td>
<td align="left"><span class="math inline">\(q + q (q + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>vector[] ssm_smooth_eta(vector[] filter,
                        matrix[] Z, matrix[] T,
                        matrix[] R, matrix[] Q) {
  vector[ssm_smooth_eta_size(dims(Q)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[q] eta;
    matrix[q, q] var_eta;
    // system matrices
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;

    // set time-invariant matrices
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    // initialize smoother
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      if (size(R) &gt; 1) {
        R_t = R[t];
      }
      if (size(Q) &gt; 1) {
        Q_t = Q[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // update smoother
      L = ssm_filter_update_L(Z_t, T_t, K);
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      eta = Q_t * R_t &#39; * r;
      var_eta = to_symmetric_matrix(Q_t - Q_t * quad_form(N, R_t) * Q_t);
      // saving
      res[t, :q] = eta;
      res[t, (q + 1): ] = symmat_to_vector(var_eta);
    }
  }
  return res;
}</code></pre>
</div>
<div id="ssm_smooth_faststate" class="section level3">
<h3><span class="header-section-number">4.6.15</span> ssm_smooth_faststate</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>filter</strong> The results of <code>ssm_filter</code></li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span>.</p>
<p>The fast state smoother</p>
<p>The fast state smoother calculates <span class="math inline">\(\hat{\vec{\alpha}}_t = \E(\vec{\alpha}_t | \vec{y}_{1:n})\)</span>. <span class="math display">\[
\hat{\vec{\alpha}}_{t + 1} = \mat{T}_t \hat{\vec{\alpha}}_{t} + \mat{R}_t \mat{Q}_t \mat{R}&#39;_t \vec{r}_t ,
\]</span> where <span class="math inline">\(r_t\)</span> is calcualted from the state disturbance smoother. The smoother is initialized at <span class="math inline">\(t = 1\)</span> with <span class="math inline">\(\hat{\vec{\alpha}}_t = \vec{a}_1 + \mat{P}_1 \vec{r}_0\)</span>.</p>
<p>Unlike the normal state smoother, it does not calculate the variances of the smoothed state.</p>
<p>For <code>Z</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>vector[] ssm_smooth_faststate(vector[] filter,
                              vector[] c, matrix[] Z, matrix[] T,
                              matrix[] R, matrix[] Q) {
  vector[dims(Z)[3]] alpha[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r[n + 1];
    matrix[m, m] L;
    vector[m] a1;
    matrix[m, m] P1;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[p, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // set time-invariant matrices
    if (size(c) == 1) {
      c_t = c[1];
    }
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    if (size(Q) == 1 &amp;&amp; size(R) == 1) {
      RQR = quad_form(Q[1], R[1]&#39;);
    }
    // find smoothed state disturbances
    // Since I don&#39;t need to calculate the
    // variances of the smoothed disturbances,
    // I reimplement the state distrurbance smoother here
    // removing extraneous parts.
    // r goes from t = n, ..., 1, 0.
    // r_n
    r[n + 1] = rep_vector(0.0, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get filter values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating smoother
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1}
      r[t] = ssm_smooth_update_r(r[t + 1], Z_t, v, Finv, L);
    }
    // calculate smoothed states
    a1 = ssm_filter_get_a(filter[1], m, p);
    P1 = ssm_filter_get_P(filter[1], m, p);
    // r[1] = r_0
    alpha[1] = a1 + P1 * r[1];
    // 1:(n - 1) -&gt; \alpha_{2}:\alpha_{n}
    for (t in 1:(n - 1)) {
      if (size(c) &gt; 1) {
        c_t = c[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      if (size(Q) &gt; 1) {
        Q_t = Q[t];
      }
      if (size(R) &gt; 1) {
        R_t = R[t];
      }
      if (size(Q) &gt; 1 || size(R) &gt; 1) {
        RQR = quad_form(Q_t, R_t&#39;);
      }
      // `r[t + 1]` = $r_{t}$
      // alpha_{t + 1} = c_t + T_t * \alpha_t + R_t Q_t R&#39;_t r_t
      alpha[t + 1] = c_t + T_t * alpha[t] + RQR * r[t + 1];
    }
  }
  return alpha;
}



</code></pre>
</div>
</div>
<div id="simulators-and-smoothing-simulators" class="section level2">
<h2><span class="header-section-number">4.7</span> Simulators and Smoothing Simulators</h2>
<div id="ssm_sim_idx" class="section level3">
<h3><span class="header-section-number">4.7.1</span> ssm_sim_idx</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>int[,]</code> A 4 x 3 array of integers</p>
<p>Indexes of each component of <code>ssm_sim_rng</code> results.</p>
<p>The returned array has columns (length, start location, and end location) for rows: <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\varepsilon}_t\)</span>, and <span class="math inline">\(\vec{\eta}_t\)</span> in the results of <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>int[,] ssm_sim_idx(int m, int p, int q) {
  int sz[4, 3];
  // y
  sz[1, 1] = p;
  // a
  sz[2, 1] = m;
  // eps
  sz[3, 1] = p;
  // eta
  sz[4, 1] = q;
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:4) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}
</code></pre>
</div>
<div id="ssm_sim_size" class="section level3">
<h3><span class="header-section-number">4.7.2</span> ssm_sim_size</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>int</code> The number of elements</p>
<p>The number of elements in vectors returned by <code>ssm_sim_rng</code> results.</p>
<pre class="stan"><code>int ssm_sim_size(int m, int p, int q) {
  int sz;
  sz = ssm_sim_idx(m, p, q)[4, 3];
  return sz;
}
</code></pre>
</div>
<div id="ssm_sim_get_y" class="section level3">
<h3><span class="header-section-number">4.7.3</span> ssm_sim_get_y</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> vector A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\vec{y}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{y}_t\)</span> from vectors returned by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>vector ssm_sim_get_y(vector x, int m, int p, int q) {
  vector[m] y;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  y = x[idx[1, 2]:idx[1, 3]];
  return y;
}
</code></pre>
</div>
<div id="ssm_sim_get_a" class="section level3">
<h3><span class="header-section-number">4.7.4</span> ssm_sim_get_a</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{\alpha}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\alpha}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>vector ssm_sim_get_a(vector x, int m, int p, int q) {
  vector[m] a;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  a = x[idx[2, 2]:idx[2, 3]];
  return a;
}
</code></pre>
</div>
<div id="ssm_sim_get_eps" class="section level3">
<h3><span class="header-section-number">4.7.5</span> ssm_sim_get_eps</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> vector A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\vec{\varepsilon}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\varepsilon}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>vector ssm_sim_get_eps(vector x, int m, int p, int q) {
  vector[m] eps;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eps = x[idx[3, 2]:idx[3, 3]];
  return eps;
}
</code></pre>
</div>
<div id="ssm_sim_get_eta" class="section level3">
<h3><span class="header-section-number">4.7.6</span> ssm_sim_get_eta</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>int</code> <strong>m</strong> The number of states</li>
<li><code>int</code> <strong>p</strong> The length of the observation vector</li>
<li><code>int</code> <strong>q</strong> The number of state disturbances</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> vector A <span class="math inline">\(q \times 1\)</span> vector with <span class="math inline">\(\vec{\eta}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\eta}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>vector ssm_sim_get_eta(vector x, int m, int p, int q) {
  vector[m] eta;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eta = x[idx[4, 2]:idx[4, 3]];
  return eta;
}
</code></pre>
</div>
<div id="ssm_sim_rng" class="section level3">
<h3><span class="header-section-number">4.7.7</span> ssm_sim_rng</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>y</strong> Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>Array</code> of size <span class="math inline">\(n\)</span> of vectors with Draw <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\eta}_t\)</span> and <span class="math inline">\(\vec{\varepsilon}_t\)</span>. See the description.</p>
<p>Simulate from a Linear Gaussian State Space model.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>Draw <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\eta}_t\)</span> and <span class="math inline">\(\vec{\varepsilon}_t\)</span> from the state space model, <span class="math display">\[
\begin{aligned}[t]
\vec{y}_t &amp;= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}_t,  &amp;
\vec{\varepsilon}_t &amp; \sim N(0, \mat{H}_t), \\
\vec{\alpha}_{t + 1} &amp;= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}_t,  &amp;
\vec{\eta}_t &amp; \sim N(0, \mat{Q}_t), \\
&amp;&amp; \vec{\alpha}_1 &amp;\sim N(\vec{a}_1, \mat{P}_1) .
\end{aligned}
\]</span></p>
<p>The returned vectors are of length <span class="math inline">\(2 p + m + q\)</span>, in the format, <span class="math display">\[
(\vec{y}_t&#39;, \vec{\alpha}_t&#39;, \vec{\varepsilon}_t&#39;, \vec{\eta}_t&#39;) .
\]</span> Note that <span class="math inline">\(\eta_n = \vec{0}_q\)</span>. Use the functions <code>ssm_sim_get_y</code>, <code>ssm_sim_get_a</code>, <code>ssm_sim_get_eps</code>, and <code>ssm_sim_get_eta</code> to extract values from the vector.</p>
<table>
<thead>
<tr class="header">
<th align="left">element</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(y_t\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\alpha\)</span>_t</td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(p + 1\)</span></td>
<td align="left"><span class="math inline">\(p + m\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\varepsilon_t\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(p + m + 1\)</span></td>
<td align="left"><span class="math inline">\(2 p + m\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\eta_t\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
<td align="left"><span class="math inline">\(2 p + m + 1\)</span></td>
<td align="left"><span class="math inline">\(2 p + m + q\)</span></td>
</tr>
</tbody>
</table>
<p>It is preferrable to use <code>ssm_sim_get_y</code>, <code>ssm_sim_get_a</code>, <code>ssm_sim_get_eps</code>, and <code>ssm_sim_get_eta</code> to extract values from these vectors.</p>
<pre class="stan"><code>vector[] ssm_sim_rng(int n,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {
  vector[ssm_sim_size(dims(Z)[3], dims(Z)[2], dims(Q)[2])] ret[n];
  int p;
  int m;
  int q;
  p = dims(Z)[2];
  m = dims(Z)[3];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // outputs
    vector[p] y;
    vector[p] eps;
    vector[m] a;
    vector[q] eta;
    // constants
    vector[p] zero_p;
    vector[q] zero_q;
    vector[m] zero_m;
    int idx[4, 3];

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];

    idx = ssm_sim_idx(m, p, q);
    zero_p = rep_vector(0.0, p);
    zero_q = rep_vector(0.0, q);
    zero_m = rep_vector(0.0, m);
    a = multi_normal_rng(a1, P1);
    for (t in 1:n) {
      // set system matrices
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        // system matrices are n - 1 length
        if (t &lt; n) {
          if (size(c) &gt; 1) {
            c_t = c[t];
          }
          if (size(T) &gt; 1) {
            T_t = T[t];
          }
          if (size(R) &gt; 1) {
            R_t = R[t];
          }
          if (size(Q) &gt; 1) {
            Q_t = Q[t];
          }
        }
      }
      // draw forecast error
      eps = multi_normal_rng(zero_p, H_t);
      // draw observed value
      y = d_t + Z_t * a + eps;
      // since eta_t is for alpha_{t + 1}, we don&#39;t
      // draw it for t == n
      if (t == n) {
        eta = zero_q;
      } else {
        eta = multi_normal_rng(zero_q, Q_t);
      }
      // save
      ret[t, idx[1, 2]:idx[1, 3]] = y;
      ret[t, idx[2, 2]:idx[2, 3]] = a;
      ret[t, idx[3, 2]:idx[3, 3]] = eps;
      ret[t, idx[4, 2]:idx[4, 3]] = eta;
      // a_{t + 1}
      if (t &lt; n) {
        a = c_t + T_t * a + R_t * eta;
      }
    }
  }
  return ret;
}
</code></pre>
</div>
</div>
<div id="simulation-smoothers-1" class="section level2">
<h2><span class="header-section-number">4.8</span> Simulation Smoothers</h2>
<div id="ssm_simsmo_state_rng" class="section level3">
<h3><span class="header-section-number">4.8.1</span> ssm_simsmo_state_rng</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>alpha</strong> An of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing the smoothed expected values of the states, <span class="math inline">\(\E(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>. These are returned by <code>sim_smooth_faststates</code>. If <code>sim_smooth_state</code> was used, then the expected values need to first be extracted using <code>sim_smooth_state_get_mean</code>.</li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State simulation smoother</p>
<p>Draw samples from the posterior distribution of the states, <span class="math inline">\(\tilde{\vec{\alpha}}_{1:n} \sim p(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>vector[] ssm_simsmo_states_rng(vector[] alpha,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[2]] draws[size(alpha)];
    int n;
    int p;
    int m;
    int q;
    n = size(alpha);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[p] y[n];
      vector[m] alpha_hat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter with simulated y&#39;s
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      alpha_hat_plus = ssm_smooth_faststate(filter, c, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_a(sims[i], m, p, q)
                    - alpha_hat_plus[i]
                    + alpha[i]);
      }
    }
    return draws;
}
</code></pre>
</div>
<div id="ssm_simsmo_eta_rng" class="section level3">
<h3><span class="header-section-number">4.8.2</span> ssm_simsmo_eta_rng</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>eta</strong> Values returned by <code>sim_smooth_eta</code></li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(q \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\eta}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State disturbance simulation smoother</p>
<p>Draw samples from the posterior distribution of the observation disturbances, <span class="math inline">\(\tilde{\vec{\eta}}_{1:n} \sim p(\vec{\eta}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>vector[] ssm_simsmo_eta_rng(vector[] eta,
                            vector[] d, matrix[] Z, matrix[] H,
                            vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                            vector a1, matrix P1) {
    vector[dims(Q)[2]] draws[size(eta)];
    int n;
    int p;
    int m;
    int q;
    n = size(eta);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(q)] etahat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct eta samples
      etahat_plus = ssm_smooth_eta(filter, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eta(sims[i], m, p, q)
                                    - ssm_smooth_eta_get_mean(etahat_plus[i], q)
                                    + ssm_smooth_eta_get_mean(eta[i], q));
      }
    }
    return draws;
}
</code></pre>
</div>
<div id="ssm_simsmo_eps_rng" class="section level3">
<h3><span class="header-section-number">4.8.3</span> ssm_simsmo_eps_rng</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector[]</code> <strong>eps</strong> Values returned by <code>sim_smooth_eps</code></li>
<li><code>vector[]</code> <strong>d</strong> Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>Z</strong> Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>H</strong> Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>vector[]</code> <strong>c</strong> State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>matrix[]</code> <strong>T</strong> Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>R</strong> State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>matrix[]</code> <strong>Q</strong> State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>vector</code> <strong>a1</strong> Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>matrix</code> <strong>P1</strong> Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector[]</code> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>Observation disturbance simulation smoother</p>
<p>Draw samples from the posterior distribution of the observation disturbances, <span class="math inline">\(\tilde{\vec{\varepsilon}}_{1:n} \sim p(\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>vector[] ssm_simsmo_eps_rng(vector[] eps,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[2]] draws[size(eps)];
    int n;
    int p;
    int m;
    int q;
    n = size(eps);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(p)] epshat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      epshat_plus = ssm_smooth_eps(filter, Z, H, T);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eps(sims[i], m, p, q)
                    - ssm_smooth_eps_get_mean(epshat_plus[i], p)
                    + ssm_smooth_eps_get_mean(eps[i], p));
      }
    }
    return draws;
}
</code></pre>
</div>
</div>
<div id="stationary" class="section level2">
<h2><span class="header-section-number">4.9</span> Stationary</h2>
<div id="pacf_to_acf" class="section level3">
<h3><span class="header-section-number">4.9.1</span> pacf_to_acf</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> A vector of coefficients of a partial autocorrelation function</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A vector of coefficients of an Autocorrelation function</p>
<p>Partial Autocorrelations to Autocorrelations</p>
<pre class="stan"><code>vector pacf_to_acf(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  int n;
  n = num_elements(x);
  y = rep_matrix(0.0, n, n);
  for (k in 1:n) {
    for (i in 1:(k - 1)) {
      y[k, i] = y[k - 1, i] + x[k] * y[k - 1, k - i];
    }
    y[k, k] = x[k];
    print(y);
  }
  return -y[n] &#39;;
}
</code></pre>
</div>
<div id="constrain_stationary" class="section level3">
<h3><span class="header-section-number">4.9.2</span> constrain_stationary</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> An unconstrained vector in <span class="math inline">\((-\infty, \infty)\)</span></li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A vector of coefficients for a stationary AR or inverible MA process.</p>
<p>Constrain vector of coefficients to the stationary and intertible region for AR or MA functions.</p>
<p>See <span class="citation">R. H. Jones (<a href="#ref-Jones1980a">1980</a>)</span>, <span class="citation">M. C. Jones (<a href="#ref-Jones1987a">1987</a>)</span>, <span class="citation">Monahan (<a href="#ref-Monahan1984a">1984</a>)</span>, <span class="citation">Ansley and Kohn (<a href="#ref-AnsleyKohn1986a">1986</a>)</span>, and the functions <code>tools.constrain_stationary_univariate</code> and <code>tools.unconstraine_stationary_univariate</code> in <a href="http://www.statsmodels.org/dev/statespace.html#statespace-tools">statsmodels.tsa.statespace</a>.</p>
<pre class="stan"><code>vector constrain_stationary(vector x) {
  vector[num_elements(x)] r;
  int n;
  n = num_elements(x);
  // transform (-Inf, Inf) to (-1, 1)
  for (i in 1:n) {
    r[i] = x[i] / (sqrt(1.0 + pow(x[i], 2)));
  }
  // Transform PACF to ACF
  return pacf_to_acf(r);
}
</code></pre>
</div>
<div id="acf_to_pacf" class="section level3">
<h3><span class="header-section-number">4.9.3</span> acf_to_pacf</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> Coeffcients of an autocorrelation function.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> A vector of coefficients of the corresponding partial autocorrelation function.</p>
<p>Convert coefficients of an autocorrelation function to partial autocorrelations.</p>
<pre class="stan"><code>vector acf_to_pacf(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  vector[num_elements(x)] r;
  int n;
  n = num_elements(x);
  y = rep_matrix(0.0, n, n);
  y[n] = -x &#39;;
  for (j in 0:(n - 1)) {
    int k;
    k = n - j;
    for (i in 1:(k - 1)) {
      y[k - 1, i] = (y[k, i] - y[k, k] * y[k, k - i]) / (1 - pow(y[k, k], 2));
    }
  }
  r = diagonal(y);
  return r;
}
</code></pre>
</div>
<div id="unconstrain_stationary" class="section level3">
<h3><span class="header-section-number">4.9.4</span> unconstrain_stationary</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>vector</code> <strong>x</strong> Coeffcients of an autocorrelation function.</li>
</ul>
<p><strong>Return Value:</strong> <code>vector</code> Coefficients of the corresponding partial autocorrelation function.</p>
<p>Transform from stationary and invertible space to <span class="math inline">\((-\infty, \infty)\)</span>.</p>
<pre class="stan"><code>vector unconstrain_stationary(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  vector[num_elements(x)] r;
  vector[num_elements(x)] z;
  int n;
  n = num_elements(x);
  // Transform ACF to PACF
  r = acf_to_pacf(x);
  // Transform (-1, 1) to (-Inf, Inf)
  for (i in 1:n) {
    z[i] = r[i] / (sqrt(1.0 - pow(r[i], 2)));
  }
  return z;
}
</code></pre>
</div>
<div id="kronecker_prod" class="section level3">
<h3><span class="header-section-number">4.9.5</span> kronecker_prod</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>A</strong> An <span class="math inline">\(m \times n\)</span> matrix</li>
<li><code>matrix</code> <strong>B</strong> A <span class="math inline">\(p \times q\)</span> matrix</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(mp \times nq\)</span> matrix.</p>
<p>Kronecker product</p>
<p>The Kronecker product of a <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is <span class="math display">\[
A \otimes B =
\begin{bmatrix}
a_{11} B \cdots a_{1n} B \\
\vdots &amp; \ddots &amp; vdots \\
a_{m1} B &amp; \cdots &amp; a_{mn} B
\end{bmatrix} .
\]</span></p>
<pre class="stan"><code>matrix kronecker_prod(matrix A, matrix B) {
  matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
  int m;
  int n;
  int p;
  int q;
  m = rows(A);
  n = cols(A);
  p = rows(B);
  q = cols(B);
  for (i in 1:m) {
    for (j in 1:n) {
      int row_start;
      int row_end;
      int col_start;
      int col_end;
      row_start = (i - 1) * p + 1;
      row_end = (i - 1) * p + p;
      col_start = (j - 1) * q + 1;
      col_end = (j - 1) * q + 1;
      C[row_start:row_end, col_start:col_end] = A[i, j] * B;
    }
  }
  return C;
}
</code></pre>
</div>
<div id="arima_stationary_cov" class="section level3">
<h3><span class="header-section-number">4.9.6</span> arima_stationary_cov</h3>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>matrix</code> <strong>T</strong> The <span class="math inline">\(m \times m\)</span> transition matrix</li>
<li><code>matrix</code> <strong>R</strong> The <span class="math inline">\(m \times q\)</span> system disturbance selection matrix</li>
</ul>
<p><strong>Return Value:</strong> <code>matrix</code> An <span class="math inline">\(m \times m\)</span> matrix with the stationary covariance matrix.</p>
<p>Find the covariance of the stationary distribution of an ARMA model</p>
<p>The initial conditions are <span class="math inline">\(\alpha_1 \sim N(0, \sigma^2 Q_0)\)</span>, where <span class="math inline">\(Q_0\)</span> is the solution to <span class="math display">\[
(T \otimes T) \VEC(Q_0) = \VEC(R R&#39;)
\]</span> where <span class="math inline">\(\VEC(Q_0)\)</span> and <span class="math inline">\(\VEC(R R&#39;)\)</span> are the stacked columns of <span class="math inline">\(Q_0\)</span> and <span class="math inline">\(R R&#39;\)</span></p>
<p>See <span class="citation">Durbin and Koopman (<a href="#ref-DurbinKoopman2012">2012</a>)</span>, Sec 5.6.2.</p>
<pre class="stan"><code>matrix arima_stationary_cov(matrix T, matrix R) {
  matrix[rows(T), cols(T)] Q0;
  matrix[rows(T) * rows(T), rows(T) * rows(T)] TT;
  vector[rows(T) * rows(T)] RR;
  int m;
  int m2;
  m = rows(T);
  m2 = m * m;
  RR = to_vector(tcrossprod(R));
  TT = kronecker_prod(T, T);
  Q0 = to_matrix_colwise((diag_matrix(rep_vector(1.0, m2)) - TT) \ RR, m, m);
  return Q0;
}</code></pre>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-DurbinKoopman2012">
<p>Durbin, J., and S.J. Koopman. 2012. <em>Time Series Analysis by State Space Methods: Second Edition</em>. Oxford Statistical Science Series. OUP Oxford. <a href="http://books.google.com/books?id=fOq39Zh0olQC" class="uri">http://books.google.com/books?id=fOq39Zh0olQC</a>.</p>
</div>
<div id="ref-DurbinKoopman2002">
<p>Durbin, J., and S. J. Koopman. 2002. A Simple and Efficient Simulation Smoother for State Space Time Series Analysis. <em>Biometrika</em> 89 (3). Biometrika Trust: 60315. <a href="http://www.jstor.org/stable/4140605" class="uri">http://www.jstor.org/stable/4140605</a>.</p>
</div>
<div id="ref-Jones1980a">
<p>Jones, Richard H. 1980. Maximum Likelihood Fitting of ARMA Models to Time Series with Missing Observations. <em>Technometrics</em> 22 (3). [Taylor &amp; Francis, Ltd., American Statistical Association, American Society for Quality]: 38995. <a href="http://www.jstor.org/stable/1268324" class="uri">http://www.jstor.org/stable/1268324</a>.</p>
</div>
<div id="ref-Jones1987a">
<p>Jones, M. C. 1987. Randomly Choosing Parameters from the Stationarity and Invertibility Region of Autoregressive-Moving Average Models. <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em> 36 (2). [Wiley, Royal Statistical Society]: 13438. <a href="http://www.jstor.org/stable/2347544" class="uri">http://www.jstor.org/stable/2347544</a>.</p>
</div>
<div id="ref-Monahan1984a">
<p>Monahan, John F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models. <em>Biometrika</em> 71 (2): 4034. doi:<a href="https://doi.org/10.1093/biomet/71.2.403">10.1093/biomet/71.2.403</a>.</p>
</div>
<div id="ref-AnsleyKohn1986a">
<p>Ansley, Craig F., and Robert Kohn. 1986. A Note on Reparameterizing a Vector Autoregressive Moving Average Model to Enforce Stationarity. <em>Journal of Statistical Computation and Simulation</em> 24 (2): 99106. doi:<a href="https://doi.org/10.1080/00949658608810893">10.1080/00949658608810893</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="filtering-and-smoothing.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="other-software.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/jrnold/ssmodels-in-stan/edit/master/stanfunctions.Rmd",
"text": "Edit"
},
"download": ["ssmodels-in-stan.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
